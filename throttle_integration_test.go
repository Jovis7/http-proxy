package proxy

import (
	"io"
	"io/ioutil"
	"math/rand"
	"net/http"
	"net/http/httptest"
	"net/url"
	"strconv"
	"strings"
	"sync"
	"testing"
	"time"

	"github.com/getlantern/testredis"
	. "github.com/getlantern/waitforserver"
	"github.com/stretchr/testify/assert"

	"github.com/getlantern/http-proxy-lantern/common"
	"github.com/getlantern/http-proxy-lantern/throttle"
)

const (
	freeServerAddr = "127.0.0.1:18711"
	proServerAddr  = "127.0.0.1:18712"
)

func TestThrottlingFreeNoForce(t *testing.T) {
	doTestThrottling(t, false, false, freeServerAddr)
}

func TestThrottlingFreeForce(t *testing.T) {
	doTestThrottling(t, false, true, freeServerAddr)
}

func TestThrottlingProNoForce(t *testing.T) {
	doTestThrottling(t, true, false, proServerAddr)
}

func TestThrottlingProForce(t *testing.T) {
	doTestThrottling(t, true, true, proServerAddr)
}

func doTestThrottling(t *testing.T, pro, forceThrottling bool, serverAddr string) {
	sizeHeader := "X-Test-Size"
	originSite := httptest.NewServer(http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
		n, _ := strconv.Atoi(req.Header.Get(sizeHeader))
		io.CopyN(rw, rand.New(rand.NewSource(time.Now().UnixNano())), int64(n))
	}))

	origMeasuredReportingInterval := measuredReportingInterval
	measuredReportingInterval = 10 * time.Millisecond
	defer func() {
		measuredReportingInterval = origMeasuredReportingInterval
	}()

	r, err := testredis.Open()
	if !assert.NoError(t, err) {
		return
	}
	defer r.Close()

	rc := r.Client()
	defer rc.Close()

	if !assert.NoError(t, rc.HMSet("_throttle:desktop", map[string]string{throttle.DefaultCountryCode: "10485760|1024"}).Err()) {
		return
	}
	if !assert.NoError(t, rc.HMSet("_throttle:mobile", map[string]string{throttle.DefaultCountryCode: "10485760|1024"}).Err()) {
		return
	}

	proxy := &Proxy{
		Addr:               serverAddr,
		ReportingRedisAddr: "redis://" + r.Addr(),
		Token:              validToken,
		EnableReports:      true,
		IdleTimeout:        1 * time.Minute,
		Pro:                pro,
		ThrottleRefreshInterval: throttle.DefaultRefreshInterval,
		TestingLocal:            true,
	}
	if forceThrottling {
		proxy.ThrottleThreshold = 10485760
		proxy.ThrottleRate = 1024
	}
	go func() {
		assert.NoError(t, proxy.ListenAndServe())
	}()

	if !assert.NoError(t, WaitForServer("tcp", serverAddr, 10*time.Second)) {
		return
	}

	client := &http.Client{
		Transport: &http.Transport{
			DisableKeepAlives: true,
			Proxy: func(req *http.Request) (*url.URL, error) {
				return url.Parse("http://" + serverAddr)
			},
		},
	}

	makeRequest := func(url string, testSize int) (*http.Response, error) {
		req, _ := http.NewRequest(http.MethodGet, url, nil)
		req.Header.Set(common.TokenHeader, validToken)
		req.Header.Set(common.DeviceIdHeader, deviceId)
		req.Header.Set(sizeHeader, strconv.Itoa(testSize))

		resp, err := client.Do(req)
		if err != nil {
			return nil, err
		}

		_, err = io.Copy(ioutil.Discard, resp.Body)
		return resp, err
	}

	resp, err := makeRequest(originSite.URL, 9*1024*1024)
	if !assert.NoError(t, err) {
		return
	}

	resp, err = makeRequest(originSite.URL, 2*1024*1024)
	if !assert.NoError(t, err) {
		return
	}

	time.Sleep(2 * time.Second)
	start := time.Now()
	resp, err = makeRequest(originSite.URL, 512)
	if !assert.NoError(t, err) {
		return
	}
	xbq := resp.Header.Get(common.XBQHeader)
	if pro {
		assert.Empty(t, xbq)
	} else {
		assert.InDelta(t, 500*time.Millisecond, time.Since(start), float64(150*time.Millisecond),
			"throttling should be in effect for Free proxy")
		if !assert.NotEmpty(t, xbq) {
			return
		}

		parts := strings.Split(xbq, "/")
		if !assert.Len(t, parts, 3) {
			return
		}

		assert.NotEqual(t, "0", parts[0], "Should show some usage")
		assert.Equal(t, "10", parts[1], "Should show correct bandwidth limit")

		// Now test throttling concurrent connections from a single device
		start := time.Now()
		var wg sync.WaitGroup
		for i := 0; i < 4; i++ {
			wg.Add(1)
			go func() {
				_, err := makeRequest(originSite.URL, 512)
				wg.Done()
				assert.NoError(t, err)
			}()
		}
		wg.Wait()
		assert.InDelta(t, 2*time.Second, time.Since(start), float64(600*time.Millisecond),
			"throttling should be applied to the total traffic generated by the device")
	}

	result, err := rc.HMGet("_client:"+deviceId, "bytesIn", "bytesOut", "countryCode", "clientIP").Result()
	if !assert.NoError(t, err) {
		return
	}

	bytesIn, err := strconv.Atoi(result[0].(string))
	if !assert.NoError(t, err) {
		return
	}
	bytesOut, err := strconv.Atoi(result[1].(string))
	if !assert.NoError(t, err) {
		return
	}
	assert.True(t, bytesIn > 0)
	assert.True(t, bytesOut > 0)
	assert.Equal(t, "", result[2])
	assert.Equal(t, "127.0.0.1", result[3])

	ttl, err := rc.TTL("_client:" + deviceId).Result()
	if !assert.NoError(t, err) {
		return
	}
	log.Debug(ttl)
}
